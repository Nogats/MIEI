module Main where

import qualified Data.Text as T
import GlossExtras
import Graphics.Gloss

main = do inp <- getContents
          let (x,y) = tarefa5 (readPicture inp)
          putStrLn (show x ++ " " ++ show y)
--(listadeCaixasdasPics (separadordePics pic))
tarefa5 :: Picture -> (Int, Int)
tarefa5 pic = (7,7)


separadordePics :: Picture -> [Picture]
separadordePics Blank = []
separadordePics (Polygon p) = (Polygon p):[]
separadordePics (Line p) = (Line p):[]
separadordePics (Circle f) = (Circle f):[]
separadordePics (Bitmap w h dta b) = (Bitmap w h dta b):[]
separadordePics (Color c p) = separadordePics p 
-- separadordePics (Translate f1 f2 p) = 
-- separadordePics (Rotate f p) = 
-- separadordePics (Scale f1 f2 p) = 
separadordePics (Pictures (p:[])) = (separadordePics p)
separadordePics (Pictures (p:t)) = (separadordePics p)++(separadordePics (Pictures t))


listadeCaixasdasPics :: [Picture] -> [( (Float,Float),(Float,Float) )]
listadeCaixasdasPics [] = []
listadeCaixasdasPics (Blank:t) = (listadeCaixasdasPics t)
listadeCaixasdasPics ((Polygon p):t) = ((0,0),head p):(listadeCaixasdasPics t)
listadeCaixasdasPics ((Line p):t) = ((0,0),head p):(listadeCaixasdasPics t)
listadeCaixasdasPics ((Circle f):t) = ((-f,-f),(f,f)):(listadeCaixasdasPics t)
-- listadeCaixasdasPics ((Bitmap w h dta b):t) = ((-w,-h),(w,h)):(listadeCaixasdasPics t)



encontraCantos :: [( (Float,Float),(Float,Float) )] -> ( (Float,Float),(Float,Float) )
encontraCantos (((x3,y3),(x1,y1)):t) = encontraCantosAux (t) ( (x3,y3),(x1,y1) ) where
  encontraCantosAux [] ( (xmin,ymin),(xmax,ymax) ) = ( (xmin,ymin),(xmax,ymax) )
  encontraCantosAux (((x3,y3),(x1,y1)):t) ( (xmin,ymin),(xmax,ymax) ) = encontraCantosAux (t) ( (min x3 xmin,min y3 ymin),(max x1 xmax,max y1 ymax) )



-- ROTAÇAO
--  180 ->  -y
--  90  ->  ( (x3,y3),(x1,y1) ) => ( (y3,x3),(y1,x1) )
--  45  ->  



-- TODO:
-- funçao que dado uma picture calcula 2 cantos opostos (e vou usar o SD e IE) dum quadrado imaginario que comtem a picture


