{-|
Módulo: Main

Descrição: Módulo Haskell que dado um tabuleiro, efetua diversos testes ao tabuleiro de jogo.

Copyright: Francisco Oliveira <a78416@alunos.uminho.pt>   | | |   Vitor Peixoto <a79175@alunos.uminho.pt>

Resumo: Módulo contendo definições Haskell do Trabalho A da 1ª Fase do Projeto da disciplina de Laboratórios de Informática I. Este módulo contém funções que testam a funcionalidade do tabuleiro e os erros lógicos que impossibilitem a jogabilidade. Estes diversos testes estão juntos na função  "main", no entanto durante este período de testes é feito pela função "teste".
-}
--
-- == FUNÇÕES DEFINIDAS NO ESQUELETO INICIAL
--
module Main where

-- |Função que dada uma /String/, separa-a onde encontra /\\n/ e junta as diferentes /String/ criadas numa lista de /String/.
inStr :: String -> [String]
inStr [] = []
inStr ['\n'] = [[],[]]
inStr (x:xs) = case x of
    '\n' -> []:inStr xs
    otherwise -> case inStr xs of
        y:ys -> (x:y):ys
        [] -> [[x]]

-- |Função que dada uma lista de /String/ devolve os elementos da lista, agrupados e apenas separados por /\\n/. Função inversa de /inStr/.
outStr :: [String] -> String
outStr [] = "\n"
outStr t = unlines t

-- |Função principal (main).
main = do inp <- getContents
          putStr (outStr (tarefa1 (inStr inp)))

-- |Função usada para testar o tabuleiro (simulador da função /main/).
teste :: String -> IO ()
teste file = do inp <- readFile file
                putStr (outStr (tarefa1 (inStr inp)))



-- |Função que junta todos os testes do tabuleiro para que este seja funcional e pronto para rodar o jogo.
--
-- == SUBPROGRAMAS DA FUNÇÃO TAREFA1
tarefa1 :: [String] -> [String]
tarefa1 tabuleiro = if ( removeZeros (juntarNumeros tabuleiro)==[] ) then "OK":[]
                    else (show (minimum (removeZeros (juntarNumeros tabuleiro)))):[]


-- |Junta os outputs dos diferentes testes feitos ao tabuleiro.
juntarNumeros :: [String] -> [Int]
juntarNumeros tabuleiro = (testeInput tabuleiro):(testeFechada tabuleiro):(testeNumeroCaixas tabuleiro):(testeTamanhodasLinhas tabuleiro):(testeCOORDso2numeros tabuleiro):[]

-- |Remove zeros da lista, porque zero representa ausência de erros.
--
removeZeros :: [Int] -> [Int]
removeZeros x = if ((elem 0 x)==True) then removeZeros (delete1 0 x)
                else x




-- == TESTE AO TABULEIRO
-- |Verificar se apenas existem espaços, asteriscos ou pontos no tabuleiro principal.
testeInput :: [String] -> Int
testeInput tabuleiro = testeInputAux (sepTABCoord(tabuleiro)) (length (sepTABCoord(tabuleiro))) 1 where
    testeInputAux _ 0 _ = 0
    testeInputAux ([]:z) a linha = testeInputAux z (a-1) (linha+1)
    testeInputAux ((x:y):z) a linha = if (x=='#' || x==' ' || x=='.') then testeInputAux ((y):z) a linha
                                         else linha

-- |Verificar se o tabuleiro está completamente rodeado de asteriscos, ou seja, se está fechado e não há local por onde possa haver fuga.
testeFechada :: [String] -> Int
testeFechada tabuleiro = testeFechadaAux (sepTABCoord (tabuleiro)) 1 1 where
    testeFechadaAux tabuleiro 1 linha = if ((nub1 (head tabuleiro)) == "#") then (testeFechadaAux (tail tabuleiro) 0 (linha+1))
                                        else linha
    testeFechadaAux tabuleiro 0 linha | (length tabuleiro > 1) = if ( ((head (head tabuleiro)) == '#') && ((last (head tabuleiro)) == '#') ) then (testeFechadaAux (tail tabuleiro) 0 (linha+1))
                                                                    else linha
                                      | otherwise = if ((nub1 (head tabuleiro)) == "#") then 0
                                                    else linha

-- |Verificar se o número de pontos é exatamente igual ao número de caixas (dadas pelas coordenadas) no tabuleiro.
testeNumeroCaixas :: [String] -> Int
testeNumeroCaixas tabuleiro = testeNumeroCaixasAux (sepTABCoord tabuleiro) (0) ((length (sepTabCOORDpares tabuleiro)) - 1) (length tabuleiro) (length (sepTABCoord tabuleiro)) where
    testeNumeroCaixasAux ([]) pontos ncoordenadas nlinhastotal nlinhasTAB | (pontos == ncoordenadas) = 0
                                                                          | (pontos < ncoordenadas) = nlinhasTAB+1+pontos+1
                                                                          | (pontos > ncoordenadas) = nlinhastotal+1
    testeNumeroCaixasAux ((x:[]):[]) pontos ncoordenadas nlinhastotal nlinhasTAB = if (x == '.') then testeNumeroCaixasAux ([]) (pontos + 1) ncoordenadas nlinhastotal nlinhasTAB
                                                                                   else testeNumeroCaixasAux ([]) pontos ncoordenadas nlinhastotal nlinhasTAB
    testeNumeroCaixasAux ((x:[]):z) pontos ncoordenadas nlinhastotal nlinhasTAB = if (x == '.') then testeNumeroCaixasAux (z) (pontos + 1) ncoordenadas nlinhastotal nlinhasTAB
                                                                                   else testeNumeroCaixasAux (z) pontos ncoordenadas nlinhastotal nlinhasTAB
    testeNumeroCaixasAux ((x:y):z) pontos ncoordenadas nlinhastotal nlinhasTAB = if (x == '.') then testeNumeroCaixasAux ([y] ++ z) (pontos + 1) ncoordenadas nlinhastotal nlinhasTAB
                                                                                  else testeNumeroCaixasAux ([y] ++ z) pontos ncoordenadas nlinhastotal nlinhasTAB

-- |Verificar se a caixa é retângular, ou seja, se todas as linhas do tabuleiro têm o mesmo tamanho.
testeTamanhodasLinhas :: [String] -> Int
testeTamanhodasLinhas tabuleiro = testeTamanhodasLinhasAux (length (head tabuleiro)) (tail (sepTABCoord tabuleiro)) 2 where
  testeTamanhodasLinhasAux linha1 (x:[]) linha = if (linha1 == (length x)) then 0
                                                 else linha
  testeTamanhodasLinhasAux linha1 (x:y) linha = if (linha1 == (length x)) then testeTamanhodasLinhasAux linha1 y (linha+1)
                                                 else linha

-- |Verificar se as coordenadas são bidimensionais e apenas números
--
testeCOORDso2numeros :: [String] -> Int
testeCOORDso2numeros tabuleiro = testeCOORDso2numerosAux (sepTabCOORD tabuleiro) (length (sepTABCoord tabuleiro)+1) where
  testeCOORDso2numerosAux (x:[]) nlinhas = if ( ((length (words x))==2) && algarismos (head (words x)) && algarismos (last (words x)) ) then 0
                                          else nlinhas
  testeCOORDso2numerosAux (x:y) nlinhas = if ( ((length (words x))==2) && algarismos (head (words x)) && algarismos (last (words x)) ) then testeCOORDso2numerosAux y (nlinhas+1)
                                          else nlinhas

-- FALTA!!!! Verificar se as caixas e o jogador (Sokoban) estão localizados em espaços vazios ou pontos, porque o Sokoban não pode simplesmente estar em cima de uma parede ou caixa.
--
--
testePosicaoDasCOORD :: [String] -> Int
testePosicaoDasCOORD tabuleiro = testePosicaoDasCOORDaux (reverse (sepTABCoord tabuleiro)) ((length (sepTABCoord tabuleiro))+1) (sepTabCOORDpares tabuleiro) where
  testePosicaoDasCOORDaux tabuleiro linha ((x,y):[]) = if ( ((charNaPosicao tabuleiro (x,y))==' ')||((charNaPosicao tabuleiro (x,y))==('.')) ) then 0
                                                        else linha
  testePosicaoDasCOORDaux tabuleiro linha ((x,y):z) = if ( ((charNaPosicao tabuleiro (x,y))==' ')||((charNaPosicao tabuleiro (x,y))==('.')) ) then testePosicaoDasCOORDaux (updateTAB tabuleiro (x,y)) (linha+1) (z)
                                                        else linha


charNaPosicao :: [String] -> (Int,Int) -> Char
charNaPosicao ((x:y):z) (0,0) = x
charNaPosicao ((x:[]):z) (a,0) = '!'
charNaPosicao ((x:y):z) (a,0) = charNaPosicao ((y):z) (a-1,0)
charNaPosicao ((x:y):[]) (a,b) = '!'
charNaPosicao ((x:y):z) (a,b) = charNaPosicao (z) (a,b-1)

updateTAB :: [String] -> (Int,Int) -> [String]
updateTAB ((x:y):z) (a,0) = (updateTAB2 (x:y) a) : z
updateTAB ((x:y):z) (a,b) = (x:y) : updateTAB (z) (a,b-1)

updateTAB2 :: String -> Int -> String
updateTAB2 (x:y) 0 = "#" ++ y
updateTAB2 (x:y) posicao = [x] ++ updateTAB2 y (posicao-1)




-- == SEPARAR TABULEIRO DE COORDENADAS

-- |Separação do tabuleiro das coordenadas. Dá apenas o tabuleiro.
sepTABCoord :: [String] -> [String]
sepTABCoord tabuleiro = sepTABCoordAux (tabuleiro) 1 where
    sepTABCoordAux tabuleiro 1 = (head tabuleiro):sepTABCoordAux (tail tabuleiro) 0
    sepTABCoordAux [] 0 = []
    sepTABCoordAux tabuleiro 0 = if ((nub1 (head tabuleiro)) == "#") then (head tabuleiro):[]
                                    else (head tabuleiro):(sepTABCoordAux (tail tabuleiro) 0)

-- |Separação das coordenadas do tabuleiro. Dá apenas as coordenadas da localização do Sokoban e das caixas.
sepTabCOORD :: [String] -> [String]
sepTabCOORD tabuleiro = sepTabCOORDAux (tabuleiro) 1 where
    sepTabCOORDAux tabuleiro 1 = sepTabCOORDAux (tail tabuleiro) 0
    sepTabCOORDAux [] 0 = []
    sepTabCOORDAux tabuleiro 0 = if ((nub1 (head tabuleiro)) == "#") then (tail tabuleiro)
                                    else sepTabCOORDAux (tail tabuleiro) 0

-- |Separa as coordenadas uma a uma.
sepCOORD1 :: [String] -> [String]
sepCOORD1 (x:[]) = words x
sepCOORD1 (x:y)  = (words x) ++ (sepCOORD1 y)

-- |Após separar as coordenadas uma a uma, juntamo-las aos pares.
sepCOORD2 :: [String] -> [(Int,Int)]
sepCOORD2 (x:y:[]) = [((read x :: Int),(read y :: Int))]
sepCOORD2 (x:y:z)  = [((read x :: Int),(read y :: Int))] ++ sepCOORD2 z

-- |Juntamos as três anteriores funções e executamos todas apenas nesta.
--
sepTabCOORDpares :: [String] -> [(Int,Int)]
sepTabCOORDpares tabuleiro = sepCOORD2 (sepCOORD1 (sepTabCOORD tabuleiro))




-- == FUNÇÕES PREDEFINIDAS
--


algarismos :: [Char] -> Bool
algarismos [] = True
algarismos (a:b) = if (a >= '0') && (a <= '9') then algarismos b
                    else False

-- |Função predefinida que dado um elemento elimina a primeira ocorrência desse elemento numa lista.
-- 
-- EXEMPLO
--
-- >>> delete1 5 [1,3,5,6,9,5]
-- [1,3,6,9,5]
delete1 :: Eq a => a -> [a] -> [a]
delete1 a [] = []
delete1 a (x:y) = if (a==x) then y
                    else x:(delete1 a y)

-- |Função predefinida que elimina as repetições dos elementos de uma lista.
-- 
-- EXEMPLO
--
-- >>> nub1 [1,3,1,5,3,4,2,3,1,3]
-- [1,3,5,4,2]
nub1 :: Eq a => [a] -> [a]
nub1 []=[]
nub1 a = nub1Aux [] a where
  nub1Aux a [] = a
  nub1Aux a (b:bs) = if ((elem b a)== False) then (nub1Aux (a ++ [b]) bs)
                   else (nub1Aux a bs)

inp = "###\n#.#\n###\n2 2\n1 1"